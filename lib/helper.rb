# encoding: UTF-8

require_relative 'creq/reader'
require_relative 'creq/writer'
require_relative 'creq/requirement'
require_relative 'creq/repository'
require_relative 'creq/settings'

module Creq
  module Helper

    def initialize_project(dir = Dir.pwd)
      Dir.chdir(dir){
        Settings::PROJECT_FOLDERS.each {|fld|
          Dir.mkdir(fld) unless Dir.exist?(fld)
        }
      }
    end

    def inside_req(&block)
      Dir.chdir(Settings::REQ, &block)
    end

    def inside_doc(&block)
      Dir.chdir(Settings::DOC, &block)
    end

    def requirements_repository
      inside_req { Repository.() }
    end

    def check_repo
      {}.tap do |err|
        repo = inside_req { Repository.() }
        err[:duplicate_ids] = repo.duplicate_ids
        err[:wrong_parents] = repo.wrong_parents
        err[:wrong_links] = repo.wrong_links
        err[:wrong_childs] = repo.wrong_child_order
        err.delete_if {|k, v| v.empty?}
      end
    end

    # @param cmd [String] a system command
    # @return [String] full path to the command or nil if command was not found
    def which(cmd)
      ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|
        tmp = File.join(path, cmd).gsub(File::ALT_SEPARATOR, File::SEPARATOR)
        return tmp if File.exists?(tmp) && File.executable?(tmp)
      end
      nil
    end

    def create_toc(req = '')
      repo = requirements_repository
      repo = repo.find(req) if req != ''
      if repo.nil?
        puts "Requirement [#{req}] not found. Operation aborted!"
        return
      end

      slev = req != '' ? repo.level : 0
      repo.inject([], :<<)
        .tap{|a| a.delete_at(0); say "-= Table of contents =-"}
        .each{|r| puts "#{'  ' * (r.level - slev - 1)}[#{r.id}] #{r.title}"}
    end

    def write_doc_title(title, stream)
      stream.write "% #{title}\n"
      stream.write "% generated by [Creq](https://github.com/nvoynov/creq)\n"
      stream.write "  converted by [Pandoc](http://pandoc.org/)\n"
      stream.write "% on #{Time.now.strftime('%B %e, %Y at %H:%M')}\n"
    end

    def create_doc(req = '')
      repo = requirements_repository
      repo = repo.find(req) if req != ''
      if repo.nil?
        puts "Requirement [#{req}] not found. Operation aborted!"
        return
      end

      file = repo.title
      file = 'requirements' if file == ''
      inside_doc {
        open("#{file}.md", 'w') {|f|
          write_doc_title(file, f)
          FinalDocWriter.write(repo, f)
        }
      }
      puts "'doc/#{file}.md' created!"
    end

   def pandoc(req, format, options)
     unless which('pandoc') || which('pandoc.exe')
       puts "Please install 'pandoc' first."
       return
     end

     repo = requirements_repository
     repo = repo.find(req) if req != ''
     if repo.nil?
       puts "Requirement [#{req}] not found. Operation aborted!"
       return
     end
     title = repo.title
     title = 'requirements' if title == ''
     tmp = '~tmp.md'
     doc = "#{title}.#{format}"
     inside_doc {
       open(tmp, 'w') {|f|
         write_doc_title(title, f)
         PandocWriter.write(repo, f)
       }
       `pandoc -s --toc #{options} -o "#{doc}" #{tmp}`
       File.delete(tmp)
     }
     puts "File 'doc/#{doc}' created."
   end

  end
end
